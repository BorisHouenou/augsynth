################################################################################
## Main functions for augmented synthetic controls Method
################################################################################


#' Fit Augmented SCM
#' @param form outcome ~ treatment | auxillary covariates
#' @param unit Name of unit column
#' @param time Name of time column
#' @param t_int Time of intervention
#' @param data Panel data as dataframe
#' @param progfunc What function to use to impute control outcomes
#'                 Ridge=Ridge regression (allows for standard errors),
#'                 None=No outcome model,
#'                 EN=Elastic Net, RF=Random Forest, GSYN=gSynth,
#'                 MCP=MCPanel, CITS=CITS
#'                 CausalImpact=Bayesian structural time series with CausalImpact
#'                 seq2seq=Sequence to sequence learning with feedforward nets
#' @param weightfunc Weighting function to use, default is SCM
#' @param opts_out Optional options for fitting outcome model
#' @param opts_weights Optional options for fitting synth weights
#' @param cov_agg Covariate aggregation functions, if NULL then use mean with NAs omitted
#'
#' @return augsynth object that contains:
#'         \itemize{
#'          \item{"weights"}{Ridge ASCM weights}
#'          \item{"l2_imbalance"}{Imbalance in pre-period outcomes, measured by the L2 norm}
#'          \item{"scaled_l2_imbalance"}{L2 imbalance scaled by L2 imbalance of uniform weights}
#'          \item{"mhat"}{Outcome model estimate}
#'          \item{"data"}{Panel data as matrices}
#'         }
#' @export
augsynth <- function(form, unit, time, t_int, data,
                     progfunc=c("Ridge", "None", "EN", "RF", "GSYN", "MCP","CITS", "CausalImpact", "seq2seq"),
                     weightfunc=c("SCM", "None"),
                     opts_out=NULL, opts_weights=NULL,
                     cov_agg=NULL) {

    call_name <- match.call()
    
    form <- Formula::Formula(form)
    unit <- enquo(unit)
    time <- enquo(time)
    
    ## format data
    outcome <- terms(formula(form, rhs=1))[[2]]
    trt <- terms(formula(form, rhs=1))[[3]]
    wide <- format_data(outcome, trt, unit, time, t_int, data)
    synth_data <- do.call(format_synth, wide)

    ## add covariates
    if(length(form)[2] == 2) {

        ## if no aggregation functions, use the mean (omitting NAs)
        cov_agg <- c(function(x) mean(x, na.rm=T))
        
        cov_form <- update(formula(delete.response(terms(form, rhs=2, data=data))),
                           ~. - 1) ## ensure that there is no intercept

        ## pull out relevant covariates and aggregate
        pre_data <- data %>% 
            filter(!! (time) < t_int)
        model.matrix(cov_form,
                     model.frame(cov_form, pre_data,
                                 na.action=NULL) ) %>%
            data.frame() %>%
            mutate(unit=pull(pre_data, !!unit)) %>%
            group_by(unit) %>%
            summarise_all(cov_agg) %>%
            select(-unit) %>%
            as.matrix() -> Z
    } else {
        Z <- NULL
    }
    ## fit augsynth
    if(progfunc == "Ridge") {
        if(weightfunc == "SCM") {
            ## Ridge ASCM
            augsynth <- do.call(fit_ridgeaug_formatted,
                            c(list(wide_data=wide, synth_data=synth_data, Z=Z),
                              opts_out, opts_weights))
        } else if(weightfunc == "None") {
            ## Just ridge regression
            augsynth <- do.call(fit_ridgeaug_formatted,
                            c(list(wide_data=wide, synth_data=synth_data,
                                   Z=Z, ridge=T, scm=F), opts_out, opts_weights))
        }
    } else if(progfunc == "None") {
        ## Just SCM
        augsynth <- do.call(fit_ridgeaug_formatted,
                        c(list(wide_data=wide, synth_data=synth_data, Z=Z, ridge=F, scm=T), opts_weights))
    } else {
        ## Other outcome models
        augsynth <- fit_augsyn(wide, synth_data, progfunc, weightfunc, opts_out, opts_weights)
    }
    augsynth$data <- wide
    augsynth$data$time <- data %>% distinct(!!time) %>% pull(!!time)
    augsynth$data$Z <- Z
    augsynth$t_int <- t_int
    augsynth$progfunc <- progfunc
    augsynth$weightfunc <- weightfunc
    augsynth$call <- call_name
    ##format output
    class(augsynth) <- "augsynth"
    return(augsynth)
}

#' Get prediction of ATT or average outcome under control
#' @param augsynth augsynth object
#'
#' @return Vector of predicted post-treatment control averages
#' @export
predict.augsynth <- function(augsynth, type = c("att", "outcome")) {

    y <- augsynth$data$y
    trt <- augsynth$data$trt
    mhat <- augsynth$mhat
    
    m1 <- colMeans(mhat[trt==1,,drop=F])

    resid <- (y[trt==0,,drop=F] - mhat[trt==0,drop=F])

    y0 <- m1 + t(resid) %*% augsynth$weights
    if(type == "att") {
        return(colMeans(y[trt == 1,, drop = F]) - c(y0))
    } else if (type == "outcome") {
        return(y0)
    }
    return()
}


#' Print function for augsynth
#' @export
print.augsynth <- function(augsynth) {
    ## straight from lm
    cat("\nCall:\n", paste(deparse(augsynth$call), sep="\n", collapse="\n"), "\n\n", sep="")

    ## print att estimates
    att_post <- colMeans(augsynth$data$y[augsynth$data$trt == 1,,drop=F]) -
        predict(augsynth)

    cat(paste("Average ATT Estimate: ",
              format(round(mean(att_post),3), nsmall = 3), "\n\n", sep=""))
}


#' Plot function for augsynth
#' @export
plot.augsynth <- function(augsynth) {
    plot(summary(augsynth))
}


#' Summary function for augsynth
#' @export
summary.augsynth <- function(augsynth) {

    summ <- list()
    if(augsynth$progfunc == "Ridge" |
       augsynth$progfunc == "None" & augsynth$weightfunc == "SCM") {
        ridge <- augsynth$progfunc == "Ridge"
        scm <- augsynth$weightfunc == "SCM"

        ## get standard errors
        synth_data <- format_synth(augsynth$data$X, augsynth$data$trt,
                                   augsynth$data$y)

        att_se <- loo_se_ridgeaug(augsynth$data, synth_data, augsynth$data$Z,
                                  lambda=augsynth$lambda,
                                  ridge=ridge, scm=scm)
        att <- data.frame(augsynth$data$time,
                          att_se$att,
                          att_se$se)
        names(att) <- c("Time", "Estimate", "Std.Error")

        summ$att <- att
        summ$sigma <- att_se$sigma
    } else {
        ## no standard errors

        ## post treatment estimate
        att_post <- colMeans(augsynth$data$y[augsynth$data$trt == 1,,drop=F]) -
            predict(augsynth)

        ## pre treatment estimate
        att_pre <- colMeans(augsynth$data$X[augsynth$data$trt == 1,,drop=F]) -
            t(augsynth$data$X[augsynth$data$trt==0,,drop=F]) %*% augsynth$weights
        
        att <- data.frame(Time=augsynth$data$time,
                          Estimate=c(att_pre, att_post))
        att$Std.Error <- NA
        summ$att <- att
        summ$sigma <- NA
    }

    summ$t_int <- augsynth$t_int
    summ$call <- augsynth$call
    summ$l2_imbalance <- augsynth$l2_imbalance
    summ$scaled_l2_imbalance <- augsynth$scaled_l2_imbalance
    ## get estimated bias

    if(augsynth$progfunc == "Ridge") {
        mhat <- augsynth$ridge_mhat
        w <- augsynth$synw
    } else {
        mhat <- augsynth$mhat
        w <- augsynth$weights
    }
    trt <- augsynth$data$trt
    m1 <- colMeans(mhat[trt==1,,drop=F])

    summ$bias_est <- m1 - t(mhat[trt==0,,drop=F]) %*% w
    if(augsynth$progfunc == "None" | augsynth$weightfunc == "None") {
        summ$bias_est <- NA
    }
    
    class(summ) <- "summary.augsynth"
    return(summ)
}

#' Print function for summary function for augsynth
#' @export
print.summary.augsynth <- function(summ) {
    ## straight from lm
    cat("\nCall:\n", paste(deparse(summ$call), sep="\n", collapse="\n"), "\n\n", sep="")

    ## distinction between pre and post treatment
    att_est <- summ$att$Estimate
    t_total <- length(att_est)
    t_int <- summ$att %>% filter(Time <= summ$t_int) %>% nrow()
    
    att_pre <- att_est[1:(t_int-1)]
    att_post <- att_est[t_int:t_total]

    ## pool the standard error estimates to summarise it
    se_est <- summ$att$Std.Error

    se_pool <- sqrt(mean(se_est[t_int:t_total]^2))
    cat(paste("Average ATT Estimate (Pooled Std. Error): ",
              format(round(mean(att_post),3), nsmall=3), "  (",
              format(round(se_pool,3)), ")\n",
              "Std. Deviation: ",
              format(round(sqrt(mean(summ$sigma^2)),3)),
              "\n\n",
              "L2 Imbalance (Scaled): ",
              format(round(summ$l2_imbalance,3), nsmall=3), "  (",
              format(round(summ$scaled_l2_imbalance,3), nsmall=3), ")\t",
              "Avg Estimated Bias: ",
              format(round(mean(summ$bias_est), 3),nsmall=3), "\n\n",
              sep=""))


    print(summ$att[t_int:t_total,], row.names=F)
    
}

#' Plot function for summary function for augsynth
#' @export
plot.summary.augsynth <- function(summ) {

    summ$att %>%
        ggplot2::ggplot(ggplot2::aes(x=Time, y=Estimate)) +
        ggplot2::geom_ribbon(ggplot2::aes(ymin=Estimate-2*Std.Error,
                        ymax=Estimate+2*Std.Error),
                    alpha=0.2) +
        ggplot2::geom_line() +
        ggplot2::geom_vline(xintercept=summ$t_int, lty=2) +
        ggplot2::geom_hline(yintercept=0, lty=2) + 
        ggplot2::theme_bw()
    
}



#' augsynth: A package implementing the Augmented Synthetic Controls Method
#' @docType package
#' @name augsynth-package
#' @importFrom magrittr "%>%"
#' @import dplyr
#' @import LowRankQP
#' @import tidyr
NULL
